// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.I2C.Port;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import static frc.robot.Constants.DrivetrainConstants.*;
import static frc.robot.Constants.InputConstants.*;

import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.TalonFXFeedbackDevice;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANPIDController;
import com.revrobotics.CANEncoder;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.ControlType;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

import com.kauailabs.navx.frc.AHRS;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Drivetrain extends SubsystemBase
{
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax leftMotor1;
    private CANSparkMax leftMotor2;
    private CANPIDController leftPID;
    private CANEncoder leftEncoder;
    private CANSparkMax rightMotor1;
    private CANSparkMax rightMotor2;
    private CANPIDController rightPID;
    private CANEncoder rightEncoder;
    


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    private double m_deadband;

    private SpeedControllerGroup m_left;
    private SpeedControllerGroup m_right; 
    private DifferentialDrive m_differentialDrive;

    private AHRS m_navX;


    private double kF = 0.04759;
    private double kP = 0.01461;
    private double kI = 0.0;
    private double kD = 0.0;

    private double L_DEADBAND = .15;
    private double R_DEADBAND = .15;

    private final double MAX_RPM = 6000.0;
    private final double MAX_VEL = 3000;
    private final double MIN_VEL = 0;
    private final double MAX_ACCEL = 2000;
    private final int SMART_MOTION_SLOT = 0;
    private final double MIN_OUTPUT = -1;
    private final double MAX_OUTPUT = 1;
    private final double CLOSED_LOOP_RAMP = 0.5;
    private final double MAX_VELOCITY = 21549;
    private final double VELOCITY_LIMIT_PERCENTAGE = 0.5;
    private final double VELOCITY_SLOWDOWN_MODIFIER = 0.5;

    private final double INVALID_INPUT = -99;
    /**
    *
    */
    public Drivetrain()
    {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        leftMotor1 = new CANSparkMax(2, MotorType.kBrushless);
        leftMotor2 = new CANSparkMax(3, MotorType.kBrushless);
        leftMotor2.follow(leftMotor1, false);
        
        leftEncoder = leftMotor1.getEncoder();
        leftEncoder.setPositionConversionFactor(0.25);
        leftPID = leftMotor1.getPIDController();
        leftPID.setOutputRange(MIN_OUTPUT, MAX_OUTPUT);
        leftPID.setSmartMotionMaxVelocity(MAX_VEL, SMART_MOTION_SLOT);
        leftPID.setSmartMotionMinOutputVelocity(MIN_VEL, SMART_MOTION_SLOT);
        leftPID.setSmartMotionMaxAccel(MAX_ACCEL, SMART_MOTION_SLOT);

        rightMotor1 = new CANSparkMax(4, MotorType.kBrushless);
        rightMotor2 = new CANSparkMax(5, MotorType.kBrushless);
        rightMotor2.follow(rightMotor1, false);
        
        rightEncoder = rightMotor1.getEncoder();
        rightEncoder.setPositionConversionFactor(0.25);
        rightPID = rightMotor1.getPIDController();
        rightPID.setOutputRange(MIN_OUTPUT, MAX_OUTPUT);
        rightPID.setSmartMotionMaxVelocity(MAX_VEL, SMART_MOTION_SLOT);
        rightPID.setSmartMotionMinOutputVelocity(MIN_VEL, SMART_MOTION_SLOT);
        rightPID.setSmartMotionMaxAccel(MAX_ACCEL, SMART_MOTION_SLOT);

        leftPID.setP(kP);
        leftPID.setI(kI);
        leftPID.setD(kD);
        leftPID.setFF(kF);
        
        rightPID.setP(kP);
        rightPID.setI(kI);
        rightPID.setD(kD);
        rightPID.setFF(kF);

        m_navX = new AHRS(Port.kMXP);

        //Setup Differential Drive
        m_left = new SpeedControllerGroup(leftMotor1, leftMotor2);
        m_right = new SpeedControllerGroup(rightMotor1, rightMotor2); 
        m_differentialDrive = new DifferentialDrive(m_left, m_right);

        //Add deadband value to SmartDashboard
        m_deadband = DEFAULT_DEADBAND;
        SmartDashboard.putNumber("Deadband", m_deadband);
    }

    @Override
    public void periodic()
    {
        // This method will be called once per scheduler run
   

        //SmartDashboard.putNumber("Gyro Angle",gyro.getAngle());
        //SmartDashboard.putNumber("Gyro Yaw", gyro.getYaw());
        //SmartDashboard.putNumber("Gyro Pitch", gyro.getPitch());
    }

    @Override
    public void simulationPeriodic() 
    {
        // This method will be called once per scheduler run when in simulation
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // Converts joystick input adjusted for deadband to current for the motor
    public void dumbDrive(double leftPos, double rightPos) 
    {
        double retval = 0.0;
        
        retval = clampInput(leftPos, m_deadband);
        leftMotor1.set(retval * VELOCITY_LIMIT_PERCENTAGE);    

        retval = clampInput(rightPos, m_deadband);
        rightMotor1.set(retval * VELOCITY_LIMIT_PERCENTAGE);    
    }


    // Converts joystick input adjusted to a RPM for the Falcon's PIDF loop to aim for
    public void velocityDrive(double leftPos, double rightPos, boolean useSlowModifier, boolean useReverse)
    {
        double retval = 0.0;

        if(useReverse) 
        {     
            double temp = leftPos;
            leftPos = -rightPos;
            rightPos = -temp;
        }

        retval = clampInput(leftPos, m_deadband);
        if(useSlowModifier)
        {
            leftPID.setReference((retval * MAX_VELOCITY * VELOCITY_LIMIT_PERCENTAGE * VELOCITY_SLOWDOWN_MODIFIER), ControlType.kVelocity);    
        } 
        else 
        {
            leftPID.setReference((retval * MAX_VELOCITY * VELOCITY_LIMIT_PERCENTAGE), ControlType.kVelocity);
        }

        retval = clampInput(rightPos, m_deadband);
        if(useSlowModifier)
        {
            rightPID.setReference((retval * MAX_VELOCITY * VELOCITY_LIMIT_PERCENTAGE * VELOCITY_SLOWDOWN_MODIFIER), ControlType.kVelocity);    
        } 
        else 
        {
            rightPID.setReference((retval * MAX_VELOCITY * VELOCITY_LIMIT_PERCENTAGE), ControlType.kVelocity);
        }
    }

    // Stops motor usually used after the drive command ends to prevent shenanigans
    public void stop() 
    {
        leftMotor1.set(0);
        rightMotor1.set(0);
    }

    //Velocity Drive without Deadband for vision purposes
    public void visionDrive(double left, double right)
    {
        if (left > 1 || left < -1 || right > 1 || right < -1)
        {
            System.out.println("Invalid left motor input " + left);
            System.out.println("Invalid right motor input " + right);
            stop();
            return;
        }

        leftMotor1.set((left * MAX_VELOCITY));
        rightMotor1.set((right * MAX_VELOCITY));
    }

    public void arcadeDrive(double forwardMovement, double turning)
    {
        m_differentialDrive.arcadeDrive(forwardMovement, turning);
    }
    
    public double clampInput(double input, double deadband) 
    {
        double retval = 0.0;
        
        //Check if input is valid, between -1 <= input <= 1
        if((-1 <= input) && (1 >= input))
        {
            if (Math.abs(input) >= deadband)
            {
                retval = (Math.abs(input) - deadband)/(1 - deadband);

                //Check if value is supposed to be negative
                if(input < 0)
                {
                    retval = -1 * retval;
                } 
            }
        }

        return retval;
    }
}

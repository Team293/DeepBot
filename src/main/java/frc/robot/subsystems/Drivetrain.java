// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj.I2C.Port;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpiutil.math.MathUtil;

import static frc.robot.Constants.DrivetrainConstants.*;
import static frc.robot.Constants.InputConstants.*;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANPIDController;
import com.revrobotics.CANEncoder;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import com.revrobotics.ControlType;
import com.revrobotics.CANSparkMax.IdleMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.kauailabs.navx.frc.AHRS;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Drivetrain extends SubsystemBase
{
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax m_leftMotorLead;
    private CANSparkMax m_leftMotorFollow;
    private CANPIDController leftPID;
    private CANEncoder leftEncoder;
    private CANSparkMax m_rightMotorLead;
    private CANSparkMax m_rightMotorFollow;
    private CANPIDController rightPID;
    private CANEncoder rightEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    private double m_velocityLimitPercentage = DEFAULT_MAX_VELOCITY_PERCENTAGE;
    private double m_turningLimitPercentage = DEFAULT_MAX_TURNING_SPEED;
    private double m_deadband = DEFAULT_DEADBAND;

    AHRS m_navX;
    /**
    *
    */
    public Drivetrain()
    {
        m_leftMotorLead = new CANSparkMax(2, MotorType.kBrushless);
        m_leftMotorFollow = new CANSparkMax(3, MotorType.kBrushless);
        m_leftMotorFollow.follow(m_leftMotorLead, false);
        
        m_leftMotorLead.setIdleMode(IdleMode.kCoast);
        m_leftMotorFollow.setIdleMode(IdleMode.kCoast);
        leftEncoder = m_leftMotorLead.getEncoder();
        leftEncoder.setPositionConversionFactor(ENCODER_CONVERSION_FACTOR);
        leftPID = m_leftMotorLead.getPIDController();
        leftPID.setOutputRange(MIN_OUTPUT, MAX_OUTPUT);
        leftPID.setSmartMotionMaxVelocity(MAX_VELOCITY, SMART_MOTION_SLOT);
        leftPID.setSmartMotionMinOutputVelocity(MIN_VELOCITY, SMART_MOTION_SLOT);
        leftPID.setSmartMotionMaxAccel(MAX_ACCEL, SMART_MOTION_SLOT);
        
        m_rightMotorLead = new CANSparkMax(4, MotorType.kBrushless);
        m_rightMotorFollow = new CANSparkMax(5, MotorType.kBrushless);
        m_rightMotorFollow.follow(m_rightMotorLead, false);
        
        m_rightMotorLead.setIdleMode(IdleMode.kCoast);
        m_rightMotorFollow.setIdleMode(IdleMode.kCoast);
        rightEncoder = m_rightMotorLead.getEncoder();
        rightEncoder.setPositionConversionFactor(0.25);
        rightPID = m_rightMotorLead.getPIDController();
        rightPID.setOutputRange(MIN_OUTPUT, MAX_OUTPUT);
        rightPID.setSmartMotionMaxVelocity(MAX_VELOCITY, SMART_MOTION_SLOT);
        rightPID.setSmartMotionMinOutputVelocity(MIN_VELOCITY, SMART_MOTION_SLOT);
        rightPID.setSmartMotionMaxAccel(MAX_ACCEL, SMART_MOTION_SLOT);

        leftPID.setP(KP);
        leftPID.setI(KI);
        leftPID.setD(KD);
        leftPID.setFF(KF);
        
        rightPID.setP(KP);
        rightPID.setI(KI);
        rightPID.setD(KD);
        rightPID.setFF(KF);

        m_navX = new AHRS(Port.kMXP);

        //Setup SmartDashboard
        SmartDashboard.putNumber("Deadband", m_deadband);
        SmartDashboard.putNumber("Max Velocity Percentage", m_velocityLimitPercentage);
        SmartDashboard.putNumber("Max Turning Percentage", m_turningLimitPercentage);
    }

    @Override
    public void periodic()
    {
        // This method will be called once per scheduler run
        SmartDashboard.putNumber("Left Encoder Velocity", leftEncoder.getVelocity());
        SmartDashboard.putNumber("Left Encoder Position", leftEncoder.getPosition());
        SmartDashboard.putNumber("Right Encoder Velocity", rightEncoder.getVelocity());
        SmartDashboard.putNumber("Right Encoder Position", rightEncoder.getPosition());

        SmartDashboard.putNumber("NavX Heading", m_navX.getAngle());
        SmartDashboard.putNumber("NavX Heading", m_navX.getFusedHeading());
        SmartDashboard.putNumber("NavX Turn Rate", m_navX.getRate());
        SmartDashboard.putNumber("NavX X Displacement", m_navX.getDisplacementX());
        SmartDashboard.putNumber("NavX Y Displacement", m_navX.getDisplacementY());


        m_deadband = SmartDashboard.getNumber("Deadband", DEFAULT_DEADBAND);
        m_velocityLimitPercentage = SmartDashboard.getNumber("Max Velocity Percentage", DEFAULT_MAX_VELOCITY_PERCENTAGE);
        if(m_velocityLimitPercentage > 1)
        {
            m_velocityLimitPercentage = 1;
            SmartDashboard.putNumber("Max Velocity Percentage", m_velocityLimitPercentage);
        }
        else if(m_velocityLimitPercentage < 0)
        {
            m_velocityLimitPercentage = 0;
            SmartDashboard.putNumber("Max Velocity Percentage", m_velocityLimitPercentage);
        }

        m_turningLimitPercentage = SmartDashboard.getNumber("Max Turning Percentage", DEFAULT_MAX_TURNING_SPEED);
        if(m_turningLimitPercentage > 1)
        {
            m_turningLimitPercentage = 1;
            SmartDashboard.putNumber("Max Turning Percentage", m_turningLimitPercentage);
        }
        else if(m_turningLimitPercentage < 0)
        {
            m_turningLimitPercentage = 0;
            SmartDashboard.putNumber("Max Turning Percentage", m_turningLimitPercentage);
        }
    } 

    @Override
    public void simulationPeriodic() 
    {
        // This method will be called once per scheduler run when in simulation
    }

    // Converts joystick input adjusted for deadband to current for the motor
    public void dumbDrive(double leftPos, double rightPos) 
    {
        double retval = 0.0;
        
        retval = clampInput(leftPos, m_deadband);
        m_leftMotorLead.set(retval * m_velocityLimitPercentage);    

        retval = clampInput(rightPos, m_deadband);
        m_rightMotorLead.set(retval * m_velocityLimitPercentage);    
    }

    public void velocityDrive(double leftPos, double rightPos, boolean useSlowModifier, boolean useReverse)
    {
        double retval = 0.0;
        double tempValue;

        if(useReverse) 
        {     
            tempValue = leftPos;
            leftPos = -rightPos;
            rightPos = -tempValue;
        }

        retval = clampInput(leftPos, m_deadband);
        if(useSlowModifier)
        {
            //example set velocity
            leftPID.setReference(retval * MAX_VELOCITY * m_velocityLimitPercentage * VELOCITY_SLOWDOWN_MODIFIER, ControlType.kVelocity);
        } 
        else 
        {
            leftPID.setReference(retval * MAX_VELOCITY * m_velocityLimitPercentage, ControlType.kVelocity);
        }

        retval = clampInput(rightPos, m_deadband);
        if(useSlowModifier)
        {
            rightPID.setReference(retval * MAX_VELOCITY * m_velocityLimitPercentage * VELOCITY_SLOWDOWN_MODIFIER, ControlType.kVelocity);
        } 
        else 
        {
            rightPID.setReference(retval * MAX_VELOCITY * m_velocityLimitPercentage, ControlType.kVelocity);
        }
    }

    // Stops motor usually used after the drive command ends to prevent shenanigans
    public void stop() 
    {
        m_leftMotorLead.set(0);
        m_rightMotorLead.set(0);
    }

    //Velocity Drive without Deadband for vision purposes
    public void visionDrive(double left, double right)
    {
        if (left > 1 || left < -1 || right > 1 || right < -1)
        {
            System.out.println("Invalid left motor input " + left);
            System.out.println("Invalid right motor input " + right);
            stop();
            return;
        }

        leftPID.setReference((left * MAX_VELOCITY), ControlType.kVelocity);
        rightPID.setReference((right * MAX_VELOCITY), ControlType.kVelocity);
    }

    //Very much copied from the ArcadeDrive method of the DifferentialDrive class
    public void arcadeDrive(double velocity, double turning)
    {
        velocity = clampInput(velocity * m_velocityLimitPercentage,m_deadband);
        turning = clampInput(turning * m_turningLimitPercentage,m_deadband);
        double leftMotorOutput;
        double rightMotorOutput;
    
        double maxInput = Math.copySign(Math.max(Math.abs(velocity), Math.abs(turning)), velocity);
        if (velocity >= 0.0) {
            // First quadrant, else second quadrant
            if (turning >= 0.0) {
              leftMotorOutput = maxInput;
              rightMotorOutput = velocity - turning;
            } else {
              leftMotorOutput = velocity + turning;
              rightMotorOutput = maxInput;
            }
          } else {
            // Third quadrant, else fourth quadrant
            if (turning >= 0.0) {
              leftMotorOutput = velocity + turning;
              rightMotorOutput = maxInput;
            } else {
              leftMotorOutput = maxInput;
              rightMotorOutput = velocity - turning;
            }
          }
        m_leftMotorLead.set(clampInput(leftMotorOutput));
        m_rightMotorLead.set(clampInput(rightMotorOutput) * -1);
        
    }

    public void velArcadeDrive(double velocity, double turning)
    {
        velocity = clampInput(velocity * m_velocityLimitPercentage,m_deadband);
        turning = clampInput(turning * m_turningLimitPercentage,m_deadband);
        double leftMotorOutput;
        double rightMotorOutput;
    
        double maxInput = Math.copySign(Math.max(Math.abs(velocity), Math.abs(turning)), velocity);
        if (velocity >= 0.0) {
            // First quadrant, else second quadrant
            if (turning >= 0.0) {
              leftMotorOutput = maxInput;
              rightMotorOutput = velocity - turning;
            } else {
              leftMotorOutput = velocity + turning;
              rightMotorOutput = maxInput;
            }
          } else {
            // Third quadrant, else fourth quadrant
            if (turning >= 0.0) {
              leftMotorOutput = velocity + turning;
              rightMotorOutput = maxInput;
            } else {
              leftMotorOutput = maxInput;
              rightMotorOutput = velocity - turning;
            }
          }
        leftPID.setReference(leftMotorOutput * MAX_VELOCITY, ControlType.kVelocity);
        rightPID.setReference(rightMotorOutput * MAX_VELOCITY, ControlType.kVelocity);
    }

    public double clampInput(double input, double deadband) 
    {
        double retval = 0.0;
        
        //Check if input is valid, between -1 <= input <= 1
        if((-1 <= input) && (1 >= input))
        {
            if (Math.abs(input) >= deadband)
            {
                retval = (Math.abs(input) - deadband)/(1 - deadband);

                //Check if value is supposed to be negative
                if(input < 0)
                {
                    retval = -1 * retval;
                } 
            }
        }

        return retval;
    }
    
    public double clampInput(double input) 
    {
        return clampInput(input, 0.0);
    }

}

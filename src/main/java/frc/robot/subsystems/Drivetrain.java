// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.I2C.Port;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import static frc.robot.Constants.DrivetrainConstants.*;
import static frc.robot.Constants.InputConstants.*;

import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.TalonFXFeedbackDevice;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANPIDController;
import com.revrobotics.CANEncoder;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;


import com.revrobotics.ControlType;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

import com.kauailabs.navx.frc.AHRS;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Drivetrain extends SubsystemBase
{
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax leftMotor1;
    private CANSparkMax leftMotor2;
    private CANPIDController leftPID;
    private CANEncoder leftEncoder;
    private CANSparkMax rightMotor1;
    private CANSparkMax rightMotor2;
    private CANPIDController rightPID;
    private CANEncoder rightEncoder;
    


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    private double m_deadband;

    private SpeedControllerGroup m_left;
    private SpeedControllerGroup m_right; 
    private DifferentialDrive m_differentialDrive;



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private double kF = 0;
    private double kP = 9e-5;
    private double kI = 6e-7;
    private double kD = 0.0;

    private double L_DEADBAND = .15;  //TODO adjust deadband
    private double R_DEADBAND = .15;

    private final double MAX_RPM = 6000.0;
    private final double MAX_VEL = 3000;
    private final double MIN_VEL = 0;
    private final double MAX_ACCEL = 2000;
    private final int SMART_MOTION_SLOT = 0;
    private final double MIN_OUTPUT = -1;
    private final double MAX_OUTPUT = 1;
    private final double CLOSED_LOOP_RAMP = 0.5;
    private final double MAX_VELOCITY = 21549;
    private final double VELOCITY_LIMIT_PERCENTAGE = 0.5;
    private final double VELOCITY_SLOWDOWN_MODIFIER = 0.5;

    private final double INVALID_INPUT = -99;
    public double targetRPM = 0;
    /**
    *
    */
    public Drivetrain()
    {
        leftMotor1 = new CANSparkMax(2, MotorType.kBrushless);
        leftMotor2 = new CANSparkMax(3, MotorType.kBrushless);
        leftMotor2.follow(leftMotor1, false);
        
        leftEncoder = leftMotor1.getEncoder();
        leftEncoder.setPositionConversionFactor(0.25);
        leftPID = leftMotor1.getPIDController();
        leftPID.setOutputRange(MIN_OUTPUT, MAX_OUTPUT);
        leftPID.setSmartMotionMaxVelocity(MAX_VEL, SMART_MOTION_SLOT);
        leftPID.setSmartMotionMinOutputVelocity(MIN_VEL, SMART_MOTION_SLOT);
        leftPID.setSmartMotionMaxAccel(MAX_ACCEL, SMART_MOTION_SLOT);

        rightMotor1 = new CANSparkMax(4, MotorType.kBrushless);
        rightMotor2 = new CANSparkMax(5, MotorType.kBrushless);
        rightMotor2.follow(rightMotor1, false);
        
        rightEncoder = rightMotor1.getEncoder();
        rightEncoder.setPositionConversionFactor(0.25);
        rightPID = rightMotor1.getPIDController();
        rightPID.setOutputRange(MIN_OUTPUT, MAX_OUTPUT);
        rightPID.setSmartMotionMaxVelocity(MAX_VEL, SMART_MOTION_SLOT);
        rightPID.setSmartMotionMinOutputVelocity(MIN_VEL, SMART_MOTION_SLOT);
        rightPID.setSmartMotionMaxAccel(MAX_ACCEL, SMART_MOTION_SLOT);

        leftPID.setP(kP);
        leftPID.setI(kI);
        leftPID.setD(kD);
        leftPID.setFF(kF);
        
        rightPID.setP(kP);
        rightPID.setI(kI);
        rightPID.setD(kD);
        rightPID.setFF(kF);
        m_left = new SpeedControllerGroup(leftMotor1, leftMotor2);
        m_right = new SpeedControllerGroup(rightMotor1, rightMotor2);
        m_differentialDrive = new DifferentialDrive(m_left, m_right);

    }

    @Override
    public void periodic()
    {
        // This method will be called once per scheduler run
   

        //SmartDashboard.putNumber("Gyro Angle",gyro.getAngle());
        //SmartDashboard.putNumber("Gyro Yaw", gyro.getYaw());
        //SmartDashboard.putNumber("Gyro Pitch", gyro.getPitch());
    }

    @Override
    public void simulationPeriodic() 
    {
        // This method will be called once per scheduler run when in simulation
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // Converts joystick input adjusted for deadband to current for the motor
    public void dumbJoy(double left, double right){
        leftMotor1.set(left);
        rightMotor1.set(right);

        
    }

    // Converts joystick input adjusted to a RPM for the Falcon's PIDF loop to aim for
    public void velocityDrive(double leftPos, double rightPos, boolean useSlowModifier, boolean useReverse){
        double leftMotorPower = 0.0;
        double rightMotorPower = 0.0;
        
        //Reverse motor positions if needed
        if(useReverse){     
            double temp = leftPos;
            leftPos = -rightPos;
            rightPos = -temp;
        }

        //Calculate Motor Power
        leftMotorPower = calcMotorPower(leftPos, L_DEADBAND);
        rightMotorPower = calcMotorPower(rightPos, R_DEADBAND);
        
        // Checking if motor values are valid
        if ((INVALID_INPUT == leftMotorPower) || (INVALID_INPUT == rightMotorPower)) {
            System.out.println("Invalid motor input! Left motor: " + leftPos + "Right motor: " + rightPos);
            //Motor power is invalid! Stop all motors
            stop();
        } else {
            if(useSlowModifier)
            {
                leftMotorPower = leftMotorPower * VELOCITY_SLOWDOWN_MODIFIER;
                rightMotorPower = rightMotorPower * VELOCITY_SLOWDOWN_MODIFIER;
            }

            //Set motor power
            leftPID.setReference(leftMotorPower, ControlType.kVelocity);
            rightPID.setReference(rightMotorPower, ControlType.kVelocity);
        }
    }


    
    public double calcMotorPower(double input, double deadband) {
        double retval = 0.0;

        if((input < -1) || (input > 1)) { //input must be between -1 and 1
            retval = INVALID_INPUT;
        } else if(Math.abs(input) <= deadband) { //Check if input is inside the deadband
            retval = 0.0;
        } else { //Input is valid and NOT in the deadband
            //This is in RPM's
            retval = (Math.abs(input) - deadband)/(1 - deadband) * MAX_RPM;
            if(input < 0) { //Input is negative
                retval = -1 * retval;
            } 
        }
        
        return retval;
    }
    public void arcadeDrive(double forwardMovement, double turning)
    {
        m_differentialDrive.arcadeDrive(forwardMovement, turning);
    }
    public void stop() 
    {
        leftMotor1.set(0);
        rightMotor1.set(0);
    }
    public void visionDrive(double left, double right)
    {
        if (left > 1 || left < -1 || right > 1 || right < -1)
        {
            System.out.println("Invalid left motor input " + left);
            System.out.println("Invalid right motor input " + right);
            stop();
            return;
        }

        leftMotor1.set((left * MAX_VELOCITY));
        rightMotor1.set((right * MAX_VELOCITY));
    }
}
